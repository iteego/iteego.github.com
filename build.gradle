import com.amazonaws.*
import com.amazonaws.auth.*
import com.amazonaws.services.s3.*
import com.amazonaws.services.s3.model.*

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.amazonaws:aws-java-sdk-s3:1.11.50'
  }
}

task publish << {
  def s3Credentials = new BasicAWSCredentials(awsKey, awsSecret)
  def s3Client = new AmazonS3Client(s3Credentials, new ClientConfiguration().withProtocol(Protocol.HTTPS))
  File releasesDir = new File('_site')
  if (!releasesDir.isDirectory()) throw new GradleException("Release directory ${releasesDir} not valid!")

  def filesToInclude = 'html|css|js|jpg|gif|ttf|eot|woff|svg|png'.tokenize('|')

  println ""
  println "Legend: == not changed | >> changed, uploading | !! on s3, not on local, removing"
  println ""

  awsS3Bucket.tokenize(",").each { bucket ->
    // existingFiles : List<S3ObjectSummary>
    def existingByKey = s3Client.listObjects(bucket).objectSummaries.findAll { 
      // only files, not directories
      !it.key.endsWith('/') 
    }.collectEntries { 
      [it.key, it] 
    }

    println "> S3 bucket: $bucket"
    int fileCount = 0
    int removeCount = 0
    int skipCount = 0
    releasesDir.eachFileRecurse { f ->
      def ext = f.name.tokenize('.').last()

      if (f.isDirectory()) return
      if (!filesToInclude.any { it == ext }) return

      String key = (f.canonicalPath - releasesDir.canonicalPath).substring(1)
      if (existingByKey[key]?.eTag == md5(f)) {
        println ">   S3 == $key"
        existingByKey.remove(key)
        skipCount++
        return
      }

      s3Client.putObject bucket, key, f
      s3Client.setObjectAcl bucket, key, CannedAccessControlList.PublicRead
      println ">   S3 >> $key"
      fileCount++
      existingByKey.remove(key)
    }


    existingByKey.each { key, summary -> 
      s3Client.deleteObject bucket, key
      println ">   S3 !! $key"
      removeCount++
    }
    println "> $bucket - uploaded $fileCount, removed $removeCount, skipped $skipCount"
  }
}

String md5(File f) {
  def messageDigest = java.security.MessageDigest.getInstance("MD5")

  f.eachByte(10240) { byte[] buf, int bytesRead ->
    messageDigest.update(buf, 0, bytesRead);
  }

  new BigInteger(1, messageDigest.digest()).toString(16).padLeft(32, '0' )
}


task wrapper(type: Wrapper) {
  gradleVersion = '3.1'
  jarFile = "config/gradle-wrapper/gradle-wrapper.jar"
}
